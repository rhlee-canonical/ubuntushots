#!/usr/bin/env python
# -*- coding: utf-8 -*-
"""Read Packages.gz package lists and debtags into the database"""
import logging
# Mimics: zcat Sources.gz | grep-dctrl -FMaintainer,Uploaders foo@bar -ns package
import os
import urllib
import sys
import re
import bz2
from paste.deploy import appconfig
from pylons import config
#from debian_bundle import debian_support, deb822
#import subprocess
from debshots.config.environment import load_environment
from urllib2 import urlopen
import cPickle as pickle
#import json
import tempfile
#from sqlalchemy import engine_from_config

#dde_packages_url = 'http://torf.workaround.org/ddetest'
#dde_packages_url = 'http://dde.debian.net/dde/q/udd/packages/all?t=pickle'
#dde_packages_url = 'http://dde.debian.net/dde/q/udd/packages/prio-debian-sid?t=pickle'
#packages_url = 'http://debexpo.alioth.debian.org/cgi-bin/packages'

#---------------------------

conf = appconfig('config:' + sys.argv[1])
load_environment(conf.global_conf, conf.local_conf)

log = logging.getLogger(__name__)
logging.basicConfig(
    level=logging.DEBUG,
    #level=logging.INFO,
    #level=logging.WARNING,
    format='%(asctime)s %(levelname)s %(message)s'
    )

#logging.info("Initialising Pylons environment...")

# Initialize database
from debshots.model import meta
from debshots import model

db = model.meta.Session

EXAMPLE_ENTRY="""
{'architecture': ['all'],
 'build_essential': None,
 'conflicts': '',
 'depends': '',
 'description': 'perl script to convert an addressbook to VCARD file format',
 'drc': 'ubuntu intrepid universe',
 'enhances': '',
 'essential': None,
 'homepage': None,
 'installed_size': 108,
 'long_description': ' 2vcard is a little perl script that you can use to convert the\n popular vcard file format. Currently 2vcard can only convert addressbooks\n and alias files from the following formats: abook,eudora,juno,ldif,mutt,\n mh and pine.\n .\n The VCARD format is used by gnomecard, for example, which is used by the\n balsa email client.',
 'maintainer': 'Ubuntu MOTU Developers <ubuntu-motu@lists.ubuntu.com>',
 'origin': 'Ubuntu',
 'original_maintainer': 'Martin Albisetti <argentina@gmail.com>',
 'package': '2vcard',
 'popcon': {'insts': 4645,
            'nofiles': 2,
            'olde': 4503,
            'recent': 93,
            'vote': 47},
 'pre_depends': '',
 'priority': 'optional',
 'provides': '',
 'python_version': None,
 'recommends': '',
 'replaces': '',
 'section': 'universe/utils',
 'size': 14332,
 'suggests': '',
 'sv': '2vcard 0.5-3',
 'tag': ['implemented-in::perl', 'role::program', 'use::converting'],
 'task': None,
 'version': '0.5-3'}
"""

def unpickle(inputfd):
    unp = pickle.Unpickler(inputfd)
    # This should make it more secure
    unp.find_global = None
    while True:
        try:
            yield unp.load()
        except pickle.UnpicklingError:
            logging.error("Unpickle error")
        except EOFError:
            break


def main():
    update_debtags_vocabulary()
    return 0

    dde_packages_url = config['debshots.dde_update_url']

    # Download pickle'd file from dde to a temporary file to prevent
    # HTTP timeouts while parsing the output
    #logging.info("Downloading package information from: %s" % dde_packages_url)
    #tempname = tempfile.mktemp()
    #downloadfile = open(tempname, 'w')
    #for line in urlopen(dde_packages_url):
    #    downloadfile.write(line)
    #downloadfile.close()
    tempname = "/home/www/torf.workaround.org/ddetest"

    #for pkg in unpickle(urlopen(dde_packages_url)):
    # Parse package information from temporary file
    logging.info("Parsing package information")
    downloadfile = open(tempname, 'r')
    # "Rewind" to the start of the file
    for pkg in unpickle(downloadfile):
        #pkg = json.read(line)
        # Skip Ubuntu packages
        if pkg['origin'] is not None: continue

        logging.debug("---------")
        #print pkg
        #break
        #logging.debug(u"Package:       %s " % pkg['package'])

        match = re.search(r'^(.*?) <(.*?)>$', pkg['maintainer'])
        maint_name, maint_email = match.groups()
        maint_name=unicode(maint_name)
        maint_email=unicode(maint_email)

        logging.debug(u"Maintainer:    %s" % maint_name)
        logging.debug(u"Email:         %s" % maint_email)

        # Get first line of the description
        description = pkg['description'].split('\n')[0]
        logging.debug(u"Description:   %s" % description)

        # Get the package entry from the database (if it exists yet)
        db_binpkg = model.Package.q().filter_by(name=unicode(pkg['package'])).first()

        # If the package is not yet found in the database then create a new entry
        if not db_binpkg:
            logging.info("New package: %s", pkg['package'])
            #db_binpkg = model.Package(name=unicode(pkg['package']))
            db_binpkg = model.Package()
            db_binpkg.name=unicode(pkg['package'])
            db.add(db_binpkg)
            #db.commit()
            #return 1
        else:
            logging.info("Updating package: %s", pkg['package'])

        # Skip this entry if the package's database entry has the same version
        #if db_binpkg.version==pkg['version']:
        #    continue

        db_binpkg.description = unicode(description[:80])
        db_binpkg.section = unicode(pkg['section'])
        db_binpkg.maintainer = maint_name[:100]
        db_binpkg.maintainer_email = maint_email[:100]
        db_binpkg.homepage = unicode(pkg['homepage'] or '')[:200]
        db_binpkg.version = unicode(pkg['version'][:50])
        logging.debug("Tags: %s", pkg['tag'])
        logging.debug("Committing to database...")
        db.commit()

    logging.info("Committing to database")
    db.commit()

    downloadfile.close()
    os.unlink(tempname)


def update_debtags_vocabulary():
    """Download and update the debtags descriptions in the database"""
    logging.info("Updating debtags vocabulary")
    #for line in urlopen(config['debshots.debtags_vocabulary_url']):
    #    print line

    # Iterate over facets or tags
    # (see: http://svn.debian.org/viewsvn/debtags/vocabulary/trunk/debian-packages)
    for paragraph in generator_paragraphs(urlopen(config['debshots.debtags_vocabulary_url'])):
        # Iterate over entries in this facet or tag section
        for entry in generator_entries(paragraph):
            print entry
            #print paragraph
            print "----------"
        print "======================"
        continue
        if 'Tag' in section:    # section describing a tag
            logging.debug("Tag: %s", section['Tag'])
            # Load tag from database
            db_tag = model.Debtag.q().filter_by(tag=unicode(section['Tag'])).first()
            if not db_tag:
                # If this tag does not exist in the database it means that no package has
                # this tag assigned. It's safe to ignore it then.
                continue
            db_tag.description=unicode(section['Description']).split('\n')[0]
            # Does this tag have a facet?
            if '::' in section['Tag']:
                facet_string = section['Tag'].split('::')[0]
                db_tag.facet = unicode(facet_string)
                db_tag.facet_description = unicode(facets[facet_string])

        elif 'Facet' in section:    # section describing a facet
            logging.debug("Facet: %s", section['Facet'])
            facets[section['Facet']] = unicode(section['Description'].split('\n')[0])


def generator_paragraphs(filehandle):
    """Returns paragraphs (lines seperated by empty lines) as a generator"""
    paragraph = []
    for line in filehandle:
        if not line.strip():    # empty line
            yield paragraph
            paragraph = []
        else:
            paragraph.append(line.rstrip())


def generator_entries(paragraph):
    """Returns entries from a Debian control file styled paragraph
    
    E.g.:
        Tag: accessibility::input
        Description: Input Systems
         Applies to input methods for non-latin languages as well as special input
         systems.

    Returns:
        ['Tag: accessibility::input'],
        ['Description: Input Systems',
         'Applies to input methods for non-latin languages as well as special input',
         'systems.']
    """
    lines = []
    key = ''
    for this_line in paragraph:
        #print "this:", this_line
        # No indentation
        if not this_line.startswith(' '):
            if lines:
                #print "yield"
                yield key, '\n'.join(lines)
                key, value = this_line.split(': ', 1)
                lines = [value]
            else:
                #print "append unindented"
                key, value = this_line.split(': ', 1)
                lines.append(value)
        # Indentation
        else:
            #print "append indented"
            lines.append(this_line.lstrip())
    # Yield at end of entry
    yield key, '\n'.join(lines)


if __name__=='__main__': sys.exit(main())


#######################
#######################
#######################
#######################
#######################
#######################
#######################

tempfile = '/tmp/sources'
debtags_url = 'http://svn.debian.org/viewsvn/*checkout*/debtags/tagdb/tags'
debtags_descriptions_url = 'http://svn.debian.org/viewsvn/*checkout*/debtags/vocabulary/trunk/debian-packages'


conf = appconfig('config:' + sys.argv[1])
load_environment(conf.global_conf, conf.local_conf)

# Initialize database
from debshots import model
db = model.meta.Session

def parse_packages():
    logging.info("Parsing packages file into the packages table")
    # Remove old tempfile
    if os.path.isfile(tempfile):
        os.unlink(tempfile)

    # Get Packages.gz (lists of binary packages)
    #for arch in ('alpha', 'amd64', 'arm', 'armel', 'hppa', 'hurd-i386', 'i386',
        #'ia64', 'm68k', 'mips', 'mipsel', 'powerpc', 's390', 'sparc'):
    for arch in ('i386',): # only for testing
        for component in ('main', 'contrib'):
            url = "%s/dists/unstable/%s/binary-%s/Packages" % \
                (config['debshots.debian_mirror'], component, arch)
            logging.info("Fetching URL: %s" % url)
            debian_support.downloadFile(url, tempfile)

            logging.info("Parsing Packages.gz file into packages table")
            for pkg in deb822.Dsc.iter_paragraphs(file(tempfile)):
                logging.debug("---------")
                logging.debug("Package:       %s " % pkg['package'])

                match = re.match(r'(.+?) *\<(.+?)\>', pkg['maintainer'])
                assert match, "Couldn't parse email address from maintainer entry (%s)" % pkg['maintainer']
                maint_name, maint_email = match.groups()

                logging.debug("Maintainer:    %s" % maint_name)
                logging.debug("Email:         %s" % maint_email)

                # Get first line of the description
                description = pkg['description'].split('\n')[0]
                logging.debug("Description:   %s" % description)

                # Get the package entry from the database (if it exists yet)
                db_binpkg = model.Package.q().filter_by(name=pkg['package'].decode('utf8')).first()

                # If the package is not yet found in the database then create a new entry
                if not db_binpkg:
                    db_binpkg = model.Package(name=pkg['package'].decode('utf8'))
                    db.save(db_binpkg)

                # Skip this entry if the package's database entry has the same version
                if db_binpkg.version==pkg['version']:
                    continue

                db_binpkg.description = description[:80].decode('utf8')
                db_binpkg.section = pkg['Section'].decode('utf8')
                db_binpkg.maintainer = maint_name[:100].decode('utf8')
                db_binpkg.maintainer_email = maint_email[:100].decode('utf8')
                db_binpkg.homepage = pkg.get('Homepage', '')[:200].decode('utf8')
                db_binpkg.version = pkg['Version'][:50].decode('utf8')

    logging.info("Committing to database")
    db.commit()


def parse_debtags():
    logging.info('Parsing debtags into database')
    # Get debtags file
    logging.debug('Downloading debtags file')
    debtags_file = urllib.urlopen(debtags_url)

    for line in debtags_file:
        if ': ' not in line:
            continue
        package_name, tagstring = line.rstrip().split(': ')
        logging.debug('Found tags for package: %s', package_name)
        tags = tagstring.split(', ')
        # Get package from database
        db_package = model.Package.q().filter_by(name=unicode(package_name))
        db_package = db_package.options(model.orm.eagerload('debtags'))
        db_package = db_package.first()
        if not db_package:
            logging.debug('Package not found in database. Skipping.')
            continue
        # Remove existing tags from package
        db_package.debtags=[]
        # Add tags to package
        for tag in tags:
            logging.debug('Tag: %s', tag)
            # Get tag from database
            db_tag = model.Debtag.q().filter_by(tag=unicode(tag)).first()
            if not db_tag:
                # Debtag not yet present in the database: create it
                db_tag = model.Debtag(tag=unicode(tag))
                logging.debug('Tag not found in database. Creating new one.')
            db_package.debtags.append(db_tag)

    #logging.info("Committing to database")
    #model.Session.commit()


def parse_debtags_descriptions():
    logging.info("Parsing debtags' descriptions into database")
    # Get debtags descriptions/packages file
    logging.debug('Downloading debtags descriptions file')
    descriptions_file = urllib.urlopen(debtags_descriptions_url)

    # Store facets (there aren't that many) in a dictionary to add the information
    # to each debtag.
    facets = {}

    for paragraph in generator_paragraphs(descriptions_file):
        section = deb822.Deb822(paragraph)
        if 'Tag' in section:    # section describing a tag
            logging.debug("Tag: %s", section['Tag'])
            # Load tag from database
            db_tag = model.Debtag.q().filter_by(tag=unicode(section['Tag'])).first()
            if not db_tag:
                # If this tag does not exist in the database it means that no package has
                # this tag assigned. It's safe to ignore it then.
                continue
            db_tag.description=unicode(section['Description']).split('\n')[0]
            # Does this tag have a facet?
            if '::' in section['Tag']:
                facet_string = section['Tag'].split('::')[0]
                db_tag.facet = unicode(facet_string)
                db_tag.facet_description = unicode(facets[facet_string])

        elif 'Facet' in section:    # section describing a facet
            logging.debug("Facet: %s", section['Facet'])
            facets[section['Facet']] = unicode(section['Description'].split('\n')[0])

def remove_tags_without_description():
    """Remove tags that are unsupported (without a description in the debtags file)

    Sometimes packages use tags that are not in the list of official tags.
    This function removes them from the database because they would show up
    with a description of NULL otherwise."""
    logging.info("Removing tags without descriptions (unofficial tags)")
    for tag in model.Debtag.q():
        if tag.description is None:
            db.delete(tag)
            logging.debug("Removing tag: %s", tag.tag)

def remove_boring_packages():
    """Remove packages with certain debtags that are not worthy of screenshots

    The tags are defined in the INI file as debshots.ignore_tags"""
    ignore_tags = conf['debshots.ignore_tags'].split()
    for ignore_tag in ignore_tags:
        db_debtag = model.Debtag.q().filter_by(tag=unicode(ignore_tag)).first()
        if not db_debtag:
            logging.warning('Tag "%s" not found in database. Did you spell it right in the ini file?')
            continue

        ignore_packages = model.Package.q().join('debtags').filter(model.Debtag.tag==unicode(ignore_tag))
        for ignore_package in ignore_packages:
            db.delete(ignore_package)
            logging.debug('Deleting package: %s', ignore_package.name)

        #model.Session.delete(db_debtag)
        #logging.debug('Deleting tags (and assigned packages): %s', ignore_tag)
        #model.Session.delete(db_debtag.packages)
        # This query is too manual for my taste and not making use of SQLAlchemy.
        # Besides I would have to deal with the foreign key constraings manually.
        #model.Session.connection().execute(model.sql.text("""
        #    delete from packages
        #    where id in (
        #        select packages_to_debtags.package_id from packages_to_debtags
        #        join debtags on debtags.id=packages_to_debtags.debtag_id
        #        where debtags.tag=:tagname
        #    )
        #    """), tagname=ignore_tag)




def main():
    #parse_packages()
    #parse_debtags()
    #parse_debtags_descriptions()
    #remove_tags_without_description()
    remove_boring_packages()
    db.commit()

if __name__ == '__main__':
    main()
